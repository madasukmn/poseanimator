{"id":"utils/mathUtils.js","dependencies":[{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/package.json","includedInParent":true,"mtime":1636789466000}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MultiSpline = exports.MathUtils = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nfunction getDistance(p0, p1) {\n  return Math.sqrt((p0.x - p1.x) * (p0.x - p1.x) + (p0.y - p1.y) * (p0.y - p1.y));\n}\n\nvar MathUtils = /*#__PURE__*/function () {\n  function MathUtils() {\n    _classCallCheck(this, MathUtils);\n  }\n\n  _createClass(MathUtils, null, [{\n    key: \"lerp\",\n    value: function lerp(v0, v1, perc) {\n      return v0 + (v1 - v0) * perc;\n    }\n  }, {\n    key: \"random\",\n    value: function random(v0, v1) {\n      return v0 + Math.random() * (v1 - v0);\n    }\n  }, {\n    key: \"smoothStep\",\n    value: function smoothStep(v, min, max) {\n      var x = Math.max(0, Math.min(1, (v - min) / (max - min)));\n      return x * x * (3 - 2 * x);\n    } // Generate a transform function of p in the coordinate system defined by p0 and p1.\n\n  }, {\n    key: \"getTransformFunc\",\n    value: function getTransformFunc(p0, p1, p) {\n      var d = p1.subtract(p0);\n      var dir = d.normalize();\n      var l0 = d.length;\n      var n = dir.clone();\n      n.angle += 90;\n      var v = p.subtract(p0);\n      var x = v.dot(dir);\n      var y = v.dot(n);\n      return function (p0New, p1New) {\n        var d = p1New.subtract(p0New);\n\n        if (d.length === 0) {\n          return p0New.clone();\n        }\n\n        var scale = d.length / l0;\n        var dirNew = d.normalize();\n        var nNew = dirNew.clone();\n        nNew.angle += 90;\n        return p0New.add(dirNew.multiply(x * scale)).add(nNew.multiply(y * scale));\n      };\n    }\n  }, {\n    key: \"getClosestPointOnSegment\",\n    value: function getClosestPointOnSegment(p0, p1, p) {\n      var d = p1.subtract(p0);\n      var c = p.subtract(p0).dot(d) / d.dot(d);\n\n      if (c >= 1) {\n        return p1.clone();\n      } else if (c <= 0) {\n        return p0.clone();\n      } else {\n        return p0.add(d.multiply(c));\n      }\n    } // Check if v0 and v1 are collinear.\n    // Returns true if cosine of the angle between v0 and v1 is within threshold to 1.\n\n  }, {\n    key: \"isCollinear\",\n    value: function isCollinear(v0, v1) {\n      var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.01;\n      var colinear = false;\n\n      if (v0 && v1) {\n        var n0 = v0.normalize();\n        var n1 = v1.normalize();\n        colinear = Math.abs(n0.dot(n1)) > 1 - threshold;\n      }\n\n      return colinear;\n    }\n  }, {\n    key: \"gaussian\",\n    value: function gaussian(mean, variance) {\n      var u = 0,\n          v = 0;\n\n      while (u === 0) {\n        u = Math.random();\n      } //Converting [0,1) to (0,1)\n\n\n      while (v === 0) {\n        v = Math.random();\n      }\n\n      var value = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n      return value * variance + mean;\n    }\n  }, {\n    key: \"clamp\",\n    value: function clamp(v, minV, maxV) {\n      return Math.min(Math.max(v, minV), maxV);\n    }\n  }, {\n    key: \"selectSegments\",\n    value: function selectSegments(selectPerc, count, selectVar, segVar) {\n      var segments = [];\n      var totalSeg = 0;\n\n      for (var i = 0; i < count; i++) {\n        var seg = MathUtils.gaussian(1, segVar);\n        segments.push(seg);\n        totalSeg += seg;\n      }\n\n      for (var _i = 0; _i < segments.length; _i++) {\n        segments[_i] = segments[_i] / totalSeg;\n      }\n\n      var cursor = 0;\n      var selected = [];\n\n      for (var _i2 = 0; _i2 < count; _i2++) {\n        var s0 = cursor;\n        var s1 = cursor + segments[_i2] * MathUtils.clamp(MathUtils.gaussian(1, selectVar) * selectPerc, 0, 1);\n        selected.push([s0, s1]);\n        cursor += segments[_i2];\n      }\n\n      return selected;\n    }\n  }, {\n    key: \"isLeft\",\n    value: function isLeft(p0, p1, p) {\n      return (p1.x - p0.x) * (p.y - p0.y) - (p1.y - p0.y) * (p.x - p0.x) > 0;\n    }\n  }, {\n    key: \"packCircles\",\n    value: function packCircles(center, radius, seedCount, maxR, minR) {\n      var maxIter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n      var circles = [];\n      var iterCount = 0;\n\n      var _loop = function _loop() {\n        var _loop2 = function _loop2() {\n          var c = {\n            x: radius * (Math.random() * 2 - 1) + center.x,\n            y: radius * (Math.random() * 2 - 1) + center.y\n          };\n          if (getDistance(c, center) > radius || circles.some(function (circle) {\n            return getDistance(circle, c) < circle.radius;\n          })) return \"continue\";\n          circles.push({\n            c: c,\n            r: 0\n          });\n        };\n\n        while (circles.length < seedCount) {\n          var _ret = _loop2();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var growthIterCount = 20;\n\n        var intersects = function intersects(c0, c1) {\n          var d = getDistance(c0.c, c1.c);\n          return d < c0.r + c1.r && d > Math.abs(c0.r - c1.r);\n        };\n\n        var bound = {\n          c: center,\n          r: radius\n        };\n\n        for (var i = 0; i < growthIterCount; i++) {\n          var grew = false;\n          circles.forEach(function (s) {\n            var intersecting = circles.some(function (other) {\n              return s !== other && (intersects(s, other) || intersects(s, bound));\n            });\n\n            if (!intersecting && s.r < maxR) {\n              s.r += maxR / growthIterCount;\n              grew = true;\n            }\n          });\n          if (!grew) break;\n        }\n\n        circles = circles.filter(function (c) {\n          return c.r >= minR;\n        });\n        iterCount++;\n      };\n\n      while (circles.length < seedCount && iterCount < maxIter) {\n        _loop();\n      }\n\n      return circles;\n    }\n  }]);\n\n  return MathUtils;\n}();\n\nexports.MathUtils = MathUtils;\n\nvar KeySpline = /*#__PURE__*/function () {\n  function KeySpline(mX1, mY1, mX2, mY2) {\n    _classCallCheck(this, KeySpline);\n\n    this.mX1 = mX1;\n    this.mY1 = mY1;\n    this.mX2 = mX2;\n    this.mY2 = mY2;\n  }\n\n  _createClass(KeySpline, [{\n    key: \"get\",\n    value: function get(aX) {\n      if (this.mX1 == this.mY1 && this.mX2 == this.mY2) return aX; // linear\n\n      return this.CalcBezier(this.GetTForX(aX), this.mY1, this.mY2);\n    }\n  }, {\n    key: \"A\",\n    value: function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n  }, {\n    key: \"B\",\n    value: function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1;\n    }\n  }, {\n    key: \"C\",\n    value: function C(aA1) {\n      return 3.0 * aA1;\n    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n  }, {\n    key: \"CalcBezier\",\n    value: function CalcBezier(aT, aA1, aA2) {\n      return ((this.A(aA1, aA2) * aT + this.B(aA1, aA2)) * aT + this.C(aA1)) * aT;\n    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n  }, {\n    key: \"GetSlope\",\n    value: function GetSlope(aT, aA1, aA2) {\n      return 3.0 * this.A(aA1, aA2) * aT * aT + 2.0 * this.B(aA1, aA2) * aT + this.C(aA1);\n    }\n  }, {\n    key: \"GetTForX\",\n    value: function GetTForX(aX) {\n      // Newton raphson iteration\n      var aGuessT = aX;\n\n      for (var i = 0; i < 4; ++i) {\n        var currentSlope = this.GetSlope(aGuessT, this.mX1, this.mX2);\n        if (currentSlope == 0.0) return aGuessT;\n        var currentX = this.CalcBezier(aGuessT, this.mX1, this.mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n      }\n\n      return aGuessT;\n    }\n  }]);\n\n  return KeySpline;\n}();\n\n;\n\nvar MultiSpline = /*#__PURE__*/function () {\n  function MultiSpline() {\n    _classCallCheck(this, MultiSpline);\n\n    this.keySplines = [];\n    this.segments = [];\n    this.x0 = 0;\n    this.y0 = 0;\n  }\n\n  _createClass(MultiSpline, [{\n    key: \"add\",\n    value: function add(mX1, mY1, mX2, mY2, x1, y1) {\n      var ks = new KeySpline(mX1, mY1, mX2, mY2);\n      var x0 = this.x0;\n      var y0 = this.y0;\n\n      if (this.segments.length) {\n        x0 = this.segments[this.segments.length - 1][1].x;\n        y0 = this.segments[this.segments.length - 1][1].y;\n      }\n\n      this.keySplines.push(ks);\n      this.segments.push([{\n        x: x0,\n        y: y0\n      }, {\n        x: x1,\n        y: y1\n      }]);\n    }\n  }, {\n    key: \"get\",\n    value: function get(x) {\n      var index = -1;\n\n      for (var i = 0; i < this.segments.length; i++) {\n        if (x >= this.segments[i][0].x && x < this.segments[i][1].x) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return 0;\n      }\n\n      var seg = this.segments[index];\n      var ks = this.keySplines[index];\n      var perc = (x - seg[0].x) / (seg[1].x - seg[0].x);\n\n      if (index % 2 == 0) {\n        return MathUtils.lerp(seg[0].y, seg[1].y, ks.get(perc));\n      } else {\n        return MathUtils.lerp(seg[1].y, seg[0].y, ks.get(1 - perc));\n      }\n    }\n  }]);\n\n  return MultiSpline;\n}();\n\nexports.MultiSpline = MultiSpline;"},"sourceMaps":null,"error":null,"hash":"5faa19a1f2ee23880fd5323a32b4bc56","cacheData":{"env":{}}}