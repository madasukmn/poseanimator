{"id":"node_modules/@tensorflow-models/facemesh/dist/facemesh.esm.js","dependencies":[{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/package.json","includedInParent":true,"mtime":1636789466000},{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/facemesh/package.json","includedInParent":true,"mtime":1636887546636},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":123},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/facemesh/dist/facemesh.esm.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"},{"name":"@tensorflow/tfjs-converter","loc":{"line":17,"column":173},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/facemesh/dist/facemesh.esm.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.load = load$1;\nexports.FaceMesh = void 0;\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar _tfjsConverter = require(\"@tensorflow/tfjs-converter\");\n\n/**\n    * @license\n    * Copyright 2020 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nconst disposeBox = e => {\n  e.startEndTensor.dispose(), e.startPoint.dispose(), e.endPoint.dispose();\n},\n      createBox = e => ({\n  startEndTensor: e,\n  startPoint: (0, _tfjsCore.slice)(e, [0, 0], [-1, 2]),\n  endPoint: (0, _tfjsCore.slice)(e, [0, 2], [-1, 2])\n}),\n      scaleBox = (e, t) => {\n  const s = (0, _tfjsCore.mul)(e.startPoint, t),\n        o = (0, _tfjsCore.mul)(e.endPoint, t),\n        n = (0, _tfjsCore.concat2d)([s, o], 1);\n  return createBox(n);\n},\n      ANCHORS_CONFIG = {\n  strides: [8, 16],\n  anchors: [2, 6]\n},\n      NUM_LANDMARKS = 6;\n\nfunction generateAnchors(e, t, s) {\n  const o = [];\n\n  for (let n = 0; n < s.strides.length; n++) {\n    const i = s.strides[n],\n          r = Math.floor((t + i - 1) / i),\n          a = Math.floor((e + i - 1) / i),\n          c = s.anchors[n];\n\n    for (let e = 0; e < r; e++) {\n      const t = i * (e + .5);\n\n      for (let e = 0; e < a; e++) {\n        const s = i * (e + .5);\n\n        for (let e = 0; e < c; e++) o.push([s, t]);\n      }\n    }\n  }\n\n  return o;\n}\n\nfunction decodeBounds(e, t, s) {\n  const o = (0, _tfjsCore.slice)(e, [0, 1], [-1, 2]),\n        n = (0, _tfjsCore.add)(o, t),\n        i = (0, _tfjsCore.slice)(e, [0, 3], [-1, 2]),\n        r = (0, _tfjsCore.div)(i, s),\n        a = (0, _tfjsCore.div)(n, s),\n        c = (0, _tfjsCore.div)(r, 2),\n        l = (0, _tfjsCore.sub)(a, c),\n        d = (0, _tfjsCore.add)(a, c),\n        h = (0, _tfjsCore.mul)(l, s),\n        u = (0, _tfjsCore.mul)(d, s);\n  return (0, _tfjsCore.concat2d)([h, u], 1);\n}\n\nfunction getInputTensorDimensions(e) {\n  return e instanceof _tfjsCore.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\n\nfunction flipFaceHorizontal(e, t) {\n  let s, o, n;\n\n  if (e.topLeft instanceof _tfjsCore.Tensor && e.bottomRight instanceof _tfjsCore.Tensor) {\n    const [i, r] = (0, _tfjsCore.tidy)(() => [(0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.topLeft.slice(0, 1)), e.topLeft.slice(1, 1)]), (0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.bottomRight.slice(0, 1)), e.bottomRight.slice(1, 1)])]);\n    s = i, o = r, null != e.landmarks && (n = (0, _tfjsCore.tidy)(() => {\n      const s = (0, _tfjsCore.sub)((0, _tfjsCore.tensor1d)([t - 1, 0]), e.landmarks),\n            o = (0, _tfjsCore.tensor1d)([1, -1]);\n      return (0, _tfjsCore.mul)(s, o);\n    }));\n  } else {\n    const [i, r] = e.topLeft,\n          [a, c] = e.bottomRight;\n    s = [t - 1 - i, r], o = [t - 1 - a, c], null != e.landmarks && (n = e.landmarks.map(e => [t - 1 - e[0], e[1]]));\n  }\n\n  const i = {\n    topLeft: s,\n    bottomRight: o\n  };\n  return null != n && (i.landmarks = n), null != e.probability && (i.probability = e.probability instanceof _tfjsCore.Tensor ? e.probability.clone() : e.probability), i;\n}\n\nfunction scaleBoxFromPrediction(e, t) {\n  return (0, _tfjsCore.tidy)(() => {\n    let s;\n    return s = e.hasOwnProperty(\"box\") ? e.box : e, scaleBox(s, t).startEndTensor.squeeze();\n  });\n}\n\nclass BlazeFaceModel {\n  constructor(e, t, s, o, n, i) {\n    this.blazeFaceModel = e, this.width = t, this.height = s, this.maxFaces = o, this.anchorsData = generateAnchors(t, s, ANCHORS_CONFIG), this.anchors = (0, _tfjsCore.tensor2d)(this.anchorsData), this.inputSizeData = [t, s], this.inputSize = (0, _tfjsCore.tensor1d)([t, s]), this.iouThreshold = n, this.scoreThreshold = i;\n  }\n\n  async getBoundingBoxes(e, t, s = !0) {\n    const [o, n, i] = (0, _tfjsCore.tidy)(() => {\n      const t = e.resizeBilinear([this.width, this.height]),\n            s = (0, _tfjsCore.mul)((0, _tfjsCore.sub)(t.div(255), .5), 2),\n            o = this.blazeFaceModel.predict(s).squeeze(),\n            n = decodeBounds(o, this.anchors, this.inputSize),\n            i = (0, _tfjsCore.slice)(o, [0, 0], [-1, 1]);\n      return [o, n, (0, _tfjsCore.sigmoid)(i).squeeze()];\n    }),\n          r = console.warn;\n\n    console.warn = () => {};\n\n    const a = _tfjsCore.image.nonMaxSuppression(n, i, this.maxFaces, this.iouThreshold, this.scoreThreshold);\n\n    console.warn = r;\n    const c = await a.array();\n    a.dispose();\n    let l = c.map(e => (0, _tfjsCore.slice)(n, [e, 0], [1, -1]));\n    t || (l = await Promise.all(l.map(async e => {\n      const t = await e.array();\n      return e.dispose(), t;\n    })));\n    const d = e.shape[1],\n          h = e.shape[2];\n    let u;\n    u = t ? (0, _tfjsCore.div)([h, d], this.inputSize) : [h / this.inputSizeData[0], d / this.inputSizeData[1]];\n    const p = [];\n\n    for (let e = 0; e < l.length; e++) {\n      const n = l[e],\n            r = (0, _tfjsCore.tidy)(() => {\n        const r = createBox(n instanceof _tfjsCore.Tensor ? n : (0, _tfjsCore.tensor2d)(n));\n        if (!s) return r;\n        const a = c[e];\n        let l;\n        return l = t ? this.anchors.slice([a, 0], [1, 2]) : this.anchorsData[a], {\n          box: r,\n          landmarks: (0, _tfjsCore.slice)(o, [a, NUM_LANDMARKS - 1], [1, -1]).squeeze().reshape([NUM_LANDMARKS, -1]),\n          probability: (0, _tfjsCore.slice)(i, [a], [1]),\n          anchor: l\n        };\n      });\n      p.push(r);\n    }\n\n    return n.dispose(), i.dispose(), o.dispose(), {\n      boxes: p,\n      scaleFactor: u\n    };\n  }\n\n  async estimateFaces(e, t = !1, s = !1, o = !0) {\n    const [, n] = getInputTensorDimensions(e),\n          i = (0, _tfjsCore.tidy)(() => (e instanceof _tfjsCore.Tensor || (e = _tfjsCore.browser.fromPixels(e)), e.toFloat().expandDims(0))),\n          {\n      boxes: r,\n      scaleFactor: a\n    } = await this.getBoundingBoxes(i, t, o);\n    return i.dispose(), t ? r.map(e => {\n      const t = scaleBoxFromPrediction(e, a);\n      let i = {\n        topLeft: t.slice([0], [2]),\n        bottomRight: t.slice([2], [2])\n      };\n\n      if (o) {\n        const {\n          landmarks: t,\n          probability: s,\n          anchor: o\n        } = e,\n              n = t.add(o).mul(a);\n        i.landmarks = n, i.probability = s;\n      }\n\n      return s && (i = flipFaceHorizontal(i, n)), i;\n    }) : Promise.all(r.map(async e => {\n      const t = scaleBoxFromPrediction(e, a);\n      let i;\n\n      if (o) {\n        const [s, o, n] = await Promise.all([e.landmarks, t, e.probability].map(async e => e.array())),\n              r = e.anchor,\n              [c, l] = a,\n              d = s.map(e => [(e[0] + r[0]) * c, (e[1] + r[1]) * l]);\n        i = {\n          topLeft: o.slice(0, 2),\n          bottomRight: o.slice(2),\n          landmarks: d,\n          probability: n\n        }, disposeBox(e.box), e.landmarks.dispose(), e.probability.dispose();\n      } else {\n        const e = await t.array();\n        i = {\n          topLeft: e.slice(0, 2),\n          bottomRight: e.slice(2)\n        };\n      }\n\n      return t.dispose(), s && (i = flipFaceHorizontal(i, n)), i;\n    }));\n  }\n\n}\n\nconst BLAZEFACE_MODEL_URL = \"https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1\";\n\nasync function load({\n  maxFaces: e = 10,\n  inputWidth: t = 128,\n  inputHeight: s = 128,\n  iouThreshold: o = .3,\n  scoreThreshold: n = .75\n} = {}) {\n  const i = await (0, _tfjsConverter.loadGraphModel)(BLAZEFACE_MODEL_URL, {\n    fromTFHub: !0\n  });\n  return new BlazeFaceModel(i, t, s, e, o, n);\n}\n\nconst MESH_ANNOTATIONS = {\n  silhouette: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109],\n  lipsUpperOuter: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291],\n  lipsLowerOuter: [146, 91, 181, 84, 17, 314, 405, 321, 375, 291],\n  lipsUpperInner: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308],\n  lipsLowerInner: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308],\n  rightEyeUpper0: [246, 161, 160, 159, 158, 157, 173],\n  rightEyeLower0: [33, 7, 163, 144, 145, 153, 154, 155, 133],\n  rightEyeUpper1: [247, 30, 29, 27, 28, 56, 190],\n  rightEyeLower1: [130, 25, 110, 24, 23, 22, 26, 112, 243],\n  rightEyeUpper2: [113, 225, 224, 223, 222, 221, 189],\n  rightEyeLower2: [226, 31, 228, 229, 230, 231, 232, 233, 244],\n  rightEyeLower3: [143, 111, 117, 118, 119, 120, 121, 128, 245],\n  rightEyebrowUpper: [156, 70, 63, 105, 66, 107, 55, 193],\n  rightEyebrowLower: [35, 124, 46, 53, 52, 65],\n  leftEyeUpper0: [466, 388, 387, 386, 385, 384, 398],\n  leftEyeLower0: [263, 249, 390, 373, 374, 380, 381, 382, 362],\n  leftEyeUpper1: [467, 260, 259, 257, 258, 286, 414],\n  leftEyeLower1: [359, 255, 339, 254, 253, 252, 256, 341, 463],\n  leftEyeUpper2: [342, 445, 444, 443, 442, 441, 413],\n  leftEyeLower2: [446, 261, 448, 449, 450, 451, 452, 453, 464],\n  leftEyeLower3: [372, 340, 346, 347, 348, 349, 350, 357, 465],\n  leftEyebrowUpper: [383, 300, 293, 334, 296, 336, 285, 417],\n  leftEyebrowLower: [265, 353, 276, 283, 282, 295],\n  midwayBetweenEyes: [168],\n  noseTip: [1],\n  noseBottom: [2],\n  noseRightCorner: [98],\n  noseLeftCorner: [327],\n  rightCheek: [205],\n  leftCheek: [425]\n};\n\nfunction disposeBox$1(e) {\n  null != e && null != e.startPoint && (e.startEndTensor.dispose(), e.startPoint.dispose(), e.endPoint.dispose());\n}\n\nfunction createBox$1(e, t, s) {\n  return {\n    startEndTensor: e,\n    startPoint: null != t ? t : (0, _tfjsCore.slice)(e, [0, 0], [-1, 2]),\n    endPoint: null != s ? s : (0, _tfjsCore.slice)(e, [0, 2], [-1, 2])\n  };\n}\n\nfunction scaleBoxCoordinates(e, t) {\n  const s = (0, _tfjsCore.mul)(e.startPoint, t),\n        o = (0, _tfjsCore.mul)(e.endPoint, t);\n  return createBox$1((0, _tfjsCore.concat2d)([s, o], 1));\n}\n\nfunction getBoxSize(e) {\n  return (0, _tfjsCore.tidy)(() => {\n    const t = (0, _tfjsCore.sub)(e.endPoint, e.startPoint);\n    return (0, _tfjsCore.abs)(t);\n  });\n}\n\nfunction getBoxCenter(e) {\n  return (0, _tfjsCore.tidy)(() => {\n    const t = (0, _tfjsCore.div)((0, _tfjsCore.sub)(e.endPoint, e.startPoint), 2);\n    return (0, _tfjsCore.add)(e.startPoint, t);\n  });\n}\n\nfunction cutBoxFromImageAndResize(e, t, s) {\n  const o = t.shape[1],\n        n = t.shape[2],\n        i = e.startEndTensor;\n  return (0, _tfjsCore.tidy)(() => {\n    const e = (0, _tfjsCore.concat2d)([i.slice([0, 1], [-1, 1]), i.slice([0, 0], [-1, 1]), i.slice([0, 3], [-1, 1]), i.slice([0, 2], [-1, 1])], 0),\n          r = (0, _tfjsCore.div)(e.transpose(), [o, n, o, n]);\n    return _tfjsCore.image.cropAndResize(t, r, [0], s);\n  });\n}\n\nfunction enlargeBox(e, t = 1.5) {\n  return (0, _tfjsCore.tidy)(() => {\n    const s = getBoxCenter(e),\n          o = getBoxSize(e),\n          n = (0, _tfjsCore.mul)((0, _tfjsCore.div)(o, 2), t),\n          i = (0, _tfjsCore.sub)(s, n),\n          r = (0, _tfjsCore.add)(s, n);\n    return createBox$1((0, _tfjsCore.concat2d)([i, r], 1), i, r);\n  });\n}\n\nconst LANDMARKS_COUNT = 468,\n      UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD = .25;\n\nclass Pipeline {\n  constructor(e, t, s, o, n, i) {\n    this.regionsOfInterest = [], this.runsWithoutFaceDetector = 0, this.boundingBoxDetector = e, this.meshDetector = t, this.meshWidth = s, this.meshHeight = o, this.maxContinuousChecks = n, this.maxFaces = i;\n  }\n\n  async predict(e) {\n    if (this.shouldUpdateRegionsOfInterest()) {\n      const t = !0,\n            s = !1,\n            {\n        boxes: o,\n        scaleFactor: n\n      } = await this.boundingBoxDetector.getBoundingBoxes(e, t, s);\n      if (0 === o.length) return n.dispose(), this.clearAllRegionsOfInterest(), null;\n      const i = o.map(e => enlargeBox(scaleBoxCoordinates(e, n)));\n      o.forEach(disposeBox$1), this.updateRegionsOfInterest(i), this.runsWithoutFaceDetector = 0;\n    } else this.runsWithoutFaceDetector++;\n\n    return (0, _tfjsCore.tidy)(() => this.regionsOfInterest.map((t, s) => {\n      const o = cutBoxFromImageAndResize(t, e, [this.meshHeight, this.meshWidth]).div(255),\n            [, n, i] = this.meshDetector.predict(o),\n            r = (0, _tfjsCore.reshape)(i, [-1, 3]),\n            a = (0, _tfjsCore.div)(getBoxSize(t), [this.meshWidth, this.meshHeight]),\n            c = (0, _tfjsCore.mul)(r, a.concat((0, _tfjsCore.tensor2d)([1], [1, 1]), 1)).add(t.startPoint.concat((0, _tfjsCore.tensor2d)([0], [1, 1]), 1)),\n            l = this.calculateLandmarksBoundingBox(c);\n      return disposeBox$1(this.regionsOfInterest[s]), this.regionsOfInterest[s] = l, {\n        coords: r,\n        scaledCoords: c,\n        box: l,\n        flag: n.squeeze()\n      };\n    }));\n  }\n\n  updateRegionsOfInterest(e) {\n    for (let t = 0; t < e.length; t++) {\n      const s = e[t],\n            o = this.regionsOfInterest[t];\n      let n = 0;\n\n      if (o && o.startPoint) {\n        const [e, t, i, r] = s.startEndTensor.arraySync()[0],\n              [a, c, l, d] = o.startEndTensor.arraySync()[0],\n              h = Math.max(e, a),\n              u = Math.max(t, c),\n              p = (Math.min(i, l) - h) * (Math.min(r, d) - u);\n        n = p / ((i - e) * (r - t) + (l - a) * (d - t) - p);\n      }\n\n      n > UPDATE_REGION_OF_INTEREST_IOU_THRESHOLD ? disposeBox$1(s) : (this.regionsOfInterest[t] = s, disposeBox$1(o));\n    }\n\n    for (let t = e.length; t < this.regionsOfInterest.length; t++) disposeBox$1(this.regionsOfInterest[t]);\n\n    this.regionsOfInterest = this.regionsOfInterest.slice(0, e.length);\n  }\n\n  clearRegionOfInterest(e) {\n    null != this.regionsOfInterest[e] && (disposeBox$1(this.regionsOfInterest[e]), this.regionsOfInterest = [...this.regionsOfInterest.slice(0, e), ...this.regionsOfInterest.slice(e + 1)]);\n  }\n\n  clearAllRegionsOfInterest() {\n    for (let e = 0; e < this.regionsOfInterest.length; e++) disposeBox$1(this.regionsOfInterest[e]);\n\n    this.regionsOfInterest = [];\n  }\n\n  shouldUpdateRegionsOfInterest() {\n    const e = this.regionsOfInterest.length,\n          t = 0 === e;\n    return 1 === this.maxFaces || t ? t : e !== this.maxFaces && this.runsWithoutFaceDetector >= this.maxContinuousChecks;\n  }\n\n  calculateLandmarksBoundingBox(e) {\n    const t = e.slice([0, 0], [LANDMARKS_COUNT, 1]),\n          s = e.slice([0, 1], [LANDMARKS_COUNT, 1]);\n    return enlargeBox(createBox$1((0, _tfjsCore.stack)([t.min(), s.min(), t.max(), s.max()]).expandDims(0)));\n  }\n\n}\n\nconst FACEMESH_GRAPHMODEL_PATH = \"https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1\",\n      MESH_MODEL_INPUT_WIDTH = 192,\n      MESH_MODEL_INPUT_HEIGHT = 192;\n\nasync function load$1({\n  maxContinuousChecks: e = 5,\n  detectionConfidence: t = .9,\n  maxFaces: s = 10,\n  iouThreshold: o = .3,\n  scoreThreshold: n = .75\n} = {}) {\n  const [i, r] = await Promise.all([loadDetectorModel(s, o, n), loadMeshModel()]);\n  return new FaceMesh(i, r, e, t, s);\n}\n\nasync function loadDetectorModel(e, t, s) {\n  return load({\n    maxFaces: e,\n    iouThreshold: t,\n    scoreThreshold: s\n  });\n}\n\nasync function loadMeshModel() {\n  return (0, _tfjsConverter.loadGraphModel)(FACEMESH_GRAPHMODEL_PATH, {\n    fromTFHub: !0\n  });\n}\n\nfunction getInputTensorDimensions$1(e) {\n  return e instanceof _tfjsCore.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\n\nfunction flipFaceHorizontal$1(e, t) {\n  if (e.mesh instanceof _tfjsCore.Tensor) {\n    const [s, o, n, i] = (0, _tfjsCore.tidy)(() => {\n      const s = (0, _tfjsCore.tensor1d)([t - 1, 0, 0]),\n            o = (0, _tfjsCore.tensor1d)([1, -1, 1]);\n      return (0, _tfjsCore.tidy)(() => [(0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.boundingBox.topLeft.slice(0, 1)), e.boundingBox.topLeft.slice(1, 1)]), (0, _tfjsCore.concat)([(0, _tfjsCore.sub)(t - 1, e.boundingBox.bottomRight.slice(0, 1)), e.boundingBox.bottomRight.slice(1, 1)]), (0, _tfjsCore.sub)(s, e.mesh).mul(o), (0, _tfjsCore.sub)(s, e.scaledMesh).mul(o)]);\n    });\n    return Object.assign({}, e, {\n      boundingBox: {\n        topLeft: s,\n        bottomRight: o\n      },\n      mesh: n,\n      scaledMesh: i\n    });\n  }\n\n  return Object.assign({}, e, {\n    boundingBox: {\n      topLeft: [t - 1 - e.boundingBox.topLeft[0], e.boundingBox.topLeft[1]],\n      bottomRight: [t - 1 - e.boundingBox.bottomRight[0], e.boundingBox.bottomRight[1]]\n    },\n    mesh: e.mesh.map(e => {\n      const s = e.slice(0);\n      return s[0] = t - 1 - e[0], s;\n    }),\n    scaledMesh: e.scaledMesh.map(e => {\n      const s = e.slice(0);\n      return s[0] = t - 1 - e[0], s;\n    })\n  });\n}\n\nclass FaceMesh {\n  constructor(e, t, s, o, n) {\n    this.pipeline = new Pipeline(e, t, MESH_MODEL_INPUT_WIDTH, MESH_MODEL_INPUT_HEIGHT, s, n), this.detectionConfidence = o;\n  }\n\n  static getAnnotations() {\n    return MESH_ANNOTATIONS;\n  }\n\n  async estimateFaces(e, t = !1, s = !1) {\n    const [, o] = getInputTensorDimensions$1(e),\n          n = (0, _tfjsCore.tidy)(() => (e instanceof _tfjsCore.Tensor || (e = _tfjsCore.browser.fromPixels(e)), e.toFloat().expandDims(0))),\n          i = (0, _tfjsCore.env)().get(\"WEBGL_PACK_DEPTHWISECONV\");\n    (0, _tfjsCore.env)().set(\"WEBGL_PACK_DEPTHWISECONV\", !0);\n    const r = await this.pipeline.predict(n);\n    return (0, _tfjsCore.env)().set(\"WEBGL_PACK_DEPTHWISECONV\", i), n.dispose(), null != r && r.length > 0 ? Promise.all(r.map(async (e, n) => {\n      const {\n        coords: i,\n        scaledCoords: r,\n        box: a,\n        flag: c\n      } = e;\n      let l = [c];\n      t || (l = l.concat([i, r, a.startPoint, a.endPoint]));\n      const d = await Promise.all(l.map(async e => e.array())),\n            h = d[0];\n\n      if (c.dispose(), h < this.detectionConfidence && this.pipeline.clearRegionOfInterest(n), t) {\n        const e = {\n          faceInViewConfidence: h,\n          mesh: i,\n          scaledMesh: r,\n          boundingBox: {\n            topLeft: a.startPoint.squeeze(),\n            bottomRight: a.endPoint.squeeze()\n          }\n        };\n        return s ? flipFaceHorizontal$1(e, o) : e;\n      }\n\n      const [u, p, f, m] = d.slice(1);\n      r.dispose(), i.dispose();\n      let g = {\n        faceInViewConfidence: h,\n        boundingBox: {\n          topLeft: f,\n          bottomRight: m\n        },\n        mesh: u,\n        scaledMesh: p\n      };\n      s && (g = flipFaceHorizontal$1(g, o));\n      const b = {};\n\n      for (const e in MESH_ANNOTATIONS) b[e] = MESH_ANNOTATIONS[e].map(e => g.scaledMesh[e]);\n\n      return g.annotations = b, g;\n    })) : [];\n  }\n\n}\n\nexports.FaceMesh = FaceMesh;"},"sourceMaps":null,"error":null,"hash":"9b30e2fe5f6a8634a8d174abc22ecced","cacheData":{"env":{}}}