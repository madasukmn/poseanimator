{"id":"node_modules/@tensorflow-models/posenet/dist/posenet.esm.js","dependencies":[{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/package.json","includedInParent":true,"mtime":1636789466000},{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/posenet/package.json","includedInParent":true,"mtime":1636887545701},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":110},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/posenet/dist/posenet.esm.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js"},{"name":"@tensorflow/tfjs-converter","loc":{"line":17,"column":160},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow-models/posenet/dist/posenet.esm.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMultiplePoses = decodeMultiplePoses;\nexports.decodeSinglePose = decodeSinglePose;\nexports.load = load;\nexports.getAdjacentKeyPoints = getAdjacentKeyPoints;\nexports.getBoundingBox = getBoundingBox;\nexports.getBoundingBoxPoints = getBoundingBoxPoints;\nexports.scaleAndFlipPoses = scaleAndFlipPoses;\nexports.scalePose = scalePose;\nexports.version = exports.PoseNet = exports.poseChain = exports.partNames = exports.partIds = exports.partChannels = exports.MobileNet = void 0;\n\nvar tf = _interopRequireWildcard(require(\"@tensorflow/tfjs-core\"));\n\nvar _tfjsConverter = require(\"@tensorflow/tfjs-converter\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n    * @license\n    * Copyright 2019 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nvar extendStatics = function (e, t) {\n  return (extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  })(e, t);\n};\n\nfunction __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }\n\n  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\n\nvar __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function s(e) {\n      try {\n        a(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function u(e) {\n      try {\n        a(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function a(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(s, u);\n    }\n\n    a((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      s = {\n    label: 0,\n    sent: function () {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: u(0),\n    throw: u(1),\n    return: u(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function u(i) {\n    return function (u) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; s;) try {\n          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n            case 0:\n            case 1:\n              o = i;\n              break;\n\n            case 4:\n              return s.label++, {\n                value: i[1],\n                done: !1\n              };\n\n            case 5:\n              s.label++, r = i[1], i = [0];\n              continue;\n\n            case 7:\n              i = s.ops.pop(), s.trys.pop();\n              continue;\n\n            default:\n              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                s = 0;\n                continue;\n              }\n\n              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                s.label = i[1];\n                break;\n              }\n\n              if (6 === i[0] && s.label < o[1]) {\n                s.label = o[1], o = i;\n                break;\n              }\n\n              if (o && s.label < o[2]) {\n                s.label = o[2], s.ops.push(i);\n                break;\n              }\n\n              o[2] && s.ops.pop(), s.trys.pop();\n              continue;\n          }\n\n          i = t.call(e, s);\n        } catch (e) {\n          i = [6, e], r = 0;\n        } finally {\n          n = o = 0;\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, u]);\n    };\n  }\n}\n\nvar BaseModel = function () {\n  function e(e, t) {\n    this.model = e, this.outputStride = t;\n    var n = this.model.inputs[0].shape;\n    tf.util.assert(-1 === n[1] && -1 === n[2], function () {\n      return \"Input shape [\" + n[1] + \", \" + n[2] + \"] must both be equal to or -1\";\n    });\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return (0, tf.tidy)(function () {\n      var n = t.preprocessInput(e.toFloat()).expandDims(0),\n          r = t.model.predict(n).map(function (e) {\n        return e.squeeze([0]);\n      }),\n          o = t.nameOutputResults(r);\n      return {\n        heatmapScores: o.heatmap.sigmoid(),\n        offsets: o.offsets,\n        displacementFwd: o.displacementFwd,\n        displacementBwd: o.displacementBwd\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}(),\n    MobileNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return (0, tf.tidy)(function () {\n      return (0, tf.div)(e, 127.5).sub(1);\n    });\n  }, t.prototype.nameOutputResults = function (e) {\n    return {\n      offsets: e[0],\n      heatmap: e[1],\n      displacementFwd: e[2],\n      displacementBwd: e[3]\n    };\n  }, t;\n}(BaseModel);\n\nexports.MobileNet = MobileNet;\n\nfunction half(e) {\n  return Math.floor(e / 2);\n}\n\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var n = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;\n  }, e;\n}();\n\nfunction scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {\n  for (var s = i.shape, u = s[0], a = s[1], l = !0, p = Math.max(n - o, 0), c = Math.min(n + o + 1, u), f = p; f < c; ++f) {\n    for (var d = Math.max(r - o, 0), h = Math.min(r + o + 1, a), m = d; m < h; ++m) if (i.get(f, m, e) > t) {\n      l = !1;\n      break;\n    }\n\n    if (!l) break;\n  }\n\n  return l;\n}\n\nfunction buildPartWithScoreQueue(e, t, n) {\n  for (var r = n.shape, o = r[0], i = r[1], s = r[2], u = new MaxHeap(o * i * s, function (e) {\n    return e.score;\n  }), a = 0; a < o; ++a) for (var l = 0; l < i; ++l) for (var p = 0; p < s; ++p) {\n    var c = n.get(a, l, p);\n    c < e || scoreIsMaximumInLocalWindow(p, c, a, l, t, n) && u.enqueue({\n      score: c,\n      part: {\n        heatmapY: a,\n        heatmapX: l,\n        id: p\n      }\n    });\n  }\n\n  return u;\n}\n\nvar partNames = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = partNames.length,\n    partIds = partNames.reduce(function (e, t, n) {\n  return e[t] = n, e;\n}, {}),\n    connectedPartNames = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    poseChain = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    connectedPartIndices = connectedPartNames.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [partIds[t], partIds[n]];\n}),\n    partChannels = [\"left_face\", \"right_face\", \"right_upper_leg_front\", \"right_lower_leg_back\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"left_lower_leg_back\", \"right_feet\", \"right_lower_leg_front\", \"left_feet\", \"torso_front\", \"torso_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"right_lower_arm_back\", \"left_lower_arm_front\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"left_lower_arm_back\", \"right_hand\", \"right_lower_arm_front\", \"left_hand\"];\nexports.partChannels = partChannels;\nexports.poseChain = poseChain;\nexports.partIds = partIds;\nexports.partNames = partNames;\n\nfunction getOffsetPoint(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getImageCoords(e, t, n) {\n  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),\n      o = r.y,\n      i = r.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\n\nfunction clamp(e, t, n) {\n  return e < t ? t : e > n ? n : e;\n}\n\nfunction squaredDistance(e, t, n, r) {\n  var o = n - e,\n      i = r - t;\n  return o * o + i * i;\n}\n\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\n\nvar parentChildrenTuples = poseChain.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [partIds[t], partIds[n]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});\n\nfunction getDisplacement(e, t, n) {\n  var r = n.shape[2] / 2;\n  return {\n    y: n.get(t.y, t.x, e),\n    x: n.get(t.y, t.x, r + e)\n  };\n}\n\nfunction getStridedIndexNearPoint(e, t, n, r) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, n - 1),\n    x: clamp(Math.round(e.x / t), 0, r - 1)\n  };\n}\n\nfunction traverseToTargetKeypoint(e, t, n, r, o, i, s, u) {\n  void 0 === u && (u = 2);\n\n  for (var a = r.shape, l = a[0], p = a[1], c = getDisplacement(e, getStridedIndexNearPoint(t.position, i, l, p), s), f = addVectors(t.position, c), d = 0; d < u; d++) {\n    var h = getStridedIndexNearPoint(f, i, l, p),\n        m = getOffsetPoint(h.y, h.x, n, o);\n    f = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n\n  var g = getStridedIndexNearPoint(f, i, l, p),\n      _ = r.get(g.y, g.x, n);\n\n  return {\n    position: f,\n    part: partNames[n],\n    score: _\n  };\n}\n\nfunction decodePose(e, t, n, r, o, i) {\n  var s = t.shape[2],\n      u = parentToChildEdges.length,\n      a = new Array(s),\n      l = e.part,\n      p = e.score,\n      c = getImageCoords(l, r, n);\n  a[l.id] = {\n    score: p,\n    part: partNames[l.id],\n    position: c\n  };\n\n  for (var f = u - 1; f >= 0; --f) {\n    var d = parentToChildEdges[f],\n        h = childToParentEdges[f];\n    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, i));\n  }\n\n  for (f = 0; f < u; ++f) {\n    d = childToParentEdges[f], h = parentToChildEdges[f];\n    a[d] && !a[h] && (a[h] = traverseToTargetKeypoint(f, a[d], h, t, n, r, o));\n  }\n\n  return a;\n}\n\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {\n  var o = n.x,\n      i = n.y;\n  return e.some(function (e) {\n    var n = e.keypoints[r].position;\n    return squaredDistance(i, o, n.y, n.x) <= t;\n  });\n}\n\nfunction getInstanceScore(e, t, n) {\n  return n.reduce(function (n, r, o) {\n    var i = r.position,\n        s = r.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += s), n;\n  }, 0) / n.length;\n}\n\nvar kLocalMaximumRadius = 1;\n\nfunction decodeMultiplePoses(e, t, n, r, o, i, s, u) {\n  void 0 === s && (s = .5), void 0 === u && (u = 20);\n\n  for (var a = [], l = buildPartWithScoreQueue(s, kLocalMaximumRadius, e), p = u * u; a.length < i && !l.empty();) {\n    var c = l.dequeue();\n\n    if (!withinNmsRadiusOfCorrespondingPoint(a, p, getImageCoords(c.part, o, t), c.part.id)) {\n      var f = decodePose(c, e, t, o, n, r),\n          d = getInstanceScore(a, p, f);\n      a.push({\n        keypoints: f,\n        score: d\n      });\n    }\n  }\n\n  return a;\n}\n\nfunction mod(e, t) {\n  return (0, tf.tidy)(function () {\n    var n = e.div((0, tf.scalar)(t, \"int32\"));\n    return e.sub(n.mul((0, tf.scalar)(t, \"int32\")));\n  });\n}\n\nfunction argmax2d(e) {\n  var t = e.shape,\n      n = t[0],\n      r = t[1],\n      o = t[2];\n  return (0, tf.tidy)(function () {\n    var t = e.reshape([n * r, o]).argMax(0),\n        i = t.div((0, tf.scalar)(r, \"int32\")).expandDims(1),\n        s = mod(t, r).expandDims(1);\n    return (0, tf.concat)([i, s], 1);\n  });\n}\n\nfunction getPointsConfidence(e, t) {\n  for (var n = t.shape[0], r = new Float32Array(n), o = 0; o < n; o++) {\n    var i = t.get(o, 0),\n        s = t.get(o, 1);\n    r[o] = e.get(i, s, o);\n  }\n\n  return r;\n}\n\nfunction getOffsetPoint$1(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getOffsetVectors(e, t) {\n  for (var n = [], r = 0; r < NUM_KEYPOINTS; r++) {\n    var o = getOffsetPoint$1(e.get(r, 0).valueOf(), e.get(r, 1).valueOf(), r, t),\n        i = o.x,\n        s = o.y;\n    n.push(s), n.push(i);\n  }\n\n  return (0, tf.tensor2d)(n, [NUM_KEYPOINTS, 2]);\n}\n\nfunction getOffsetPoints(e, t, n) {\n  return (0, tf.tidy)(function () {\n    var r = getOffsetVectors(e, n);\n    return e.toTensor().mul((0, tf.scalar)(t, \"int32\")).toFloat().add(r);\n  });\n}\n\nfunction decodeSinglePose(e, t, n) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, o, i, s, u, a, l, p, c, f;\n    return __generator(this, function (d) {\n      switch (d.label) {\n        case 0:\n          return r = 0, o = argmax2d(e), [4, Promise.all([e.buffer(), t.buffer(), o.buffer()])];\n\n        case 1:\n          return i = d.sent(), s = i[0], u = i[1], a = i[2], [4, (l = getOffsetPoints(a, n, u)).buffer()];\n\n        case 2:\n          return p = d.sent(), c = Array.from(getPointsConfidence(s, a)), f = c.map(function (e, t) {\n            return r += e, {\n              position: {\n                y: p.get(t, 0),\n                x: p.get(t, 1)\n              },\n              part: partNames[t],\n              score: e\n            };\n          }), o.dispose(), l.dispose(), [2, {\n            keypoints: f,\n            score: r / f.length\n          }];\n      }\n    });\n  });\n}\n\nvar MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/\",\n    RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/\";\n\nfunction resNet50Checkpoint(e, t) {\n  var n = \"model-stride\" + e + \".json\";\n  return 4 === t ? RESNET50_BASE_URL + \"float/\" + n : RESNET50_BASE_URL + \"quant\" + t + \"/\" + n;\n}\n\nfunction mobileNetCheckpoint(e, t, n) {\n  var r = {\n    1: \"100\",\n    .75: \"075\",\n    .5: \"050\"\n  },\n      o = \"model-stride\" + e + \".json\";\n  return 4 === n ? MOBILENET_BASE_URL + \"float/\" + r[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + n + \"/\" + r[t] + \"/\" + o;\n}\n\nvar imageNetMean = [-123.15, -115.9, -103.06],\n    ResNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return e.add(imageNetMean);\n  }, t.prototype.nameOutputResults = function (e) {\n    var t = e[0],\n        n = e[1];\n    return {\n      offsets: e[2],\n      heatmap: e[3],\n      displacementFwd: t,\n      displacementBwd: n\n    };\n  }, t;\n}(BaseModel);\n\nfunction eitherPointDoesntMeetConfidence(e, t, n) {\n  return e < n || t < n;\n}\n\nfunction getAdjacentKeyPoints(e, t) {\n  return connectedPartIndices.reduce(function (n, r) {\n    var o = r[0],\n        i = r[1];\n    return eitherPointDoesntMeetConfidence(e[o].score, e[i].score, t) ? n : (n.push([e[o], e[i]]), n);\n  }, []);\n}\n\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n    POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\nfunction getBoundingBox(e) {\n  return e.reduce(function (e, t) {\n    var n = e.maxX,\n        r = e.maxY,\n        o = e.minX,\n        i = e.minY,\n        s = t.position,\n        u = s.x,\n        a = s.y;\n    return {\n      maxX: Math.max(n, u),\n      maxY: Math.max(r, a),\n      minX: Math.min(o, u),\n      minY: Math.min(i, a)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nfunction getBoundingBoxPoints(e) {\n  var t = getBoundingBox(e),\n      n = t.minX,\n      r = t.minY,\n      o = t.maxX,\n      i = t.maxY;\n  return [{\n    x: n,\n    y: r\n  }, {\n    x: o,\n    y: r\n  }, {\n    x: o,\n    y: i\n  }, {\n    x: n,\n    y: i\n  }];\n}\n\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return e.buffer();\n      }))];\n    });\n  });\n}\n\nfunction scalePose(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n          s = e.part,\n          u = e.position;\n      return {\n        score: i,\n        part: s,\n        position: {\n          x: u.x * n + o,\n          y: u.y * t + r\n        }\n      };\n    })\n  };\n}\n\nfunction scalePoses(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, n, r, o);\n  });\n}\n\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n          r = e.part,\n          o = e.position;\n      return {\n        score: n,\n        part: r,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\n\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\n\nfunction toValidInputResolution(e, t) {\n  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;\n}\n\nfunction validateInputResolution(e) {\n  tf.util.assert(\"number\" == typeof e || \"object\" == typeof e, function () {\n    return \"Invalid inputResolution \" + e + \". Should be a number or an object with width and height\";\n  }), \"object\" == typeof e && (tf.util.assert(\"number\" == typeof e.width, function () {\n    return \"inputResolution.width has a value of \" + e.width + \" which is invalid; it must be a number\";\n  }), tf.util.assert(\"number\" == typeof e.height, function () {\n    return \"inputResolution.height has a value of \" + e.height + \" which is invalid; it must be a number\";\n  }));\n}\n\nfunction getValidInputResolutionDimensions(e, t) {\n  return validateInputResolution(e), \"object\" == typeof e ? [toValidInputResolution(e.height, t), toValidInputResolution(e.width, t)] : [toValidInputResolution(e, t), toValidInputResolution(e, t)];\n}\n\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\n\nfunction assertValidOutputStride(e) {\n  tf.util.assert(\"number\" == typeof e, function () {\n    return \"outputStride is not a number\";\n  }), tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(e) >= 0, function () {\n    return \"outputStride of \" + e + \" is invalid. It must be either 8, 16, or 32\";\n  });\n}\n\nfunction isValidInputResolution(e, t) {\n  return (e - 1) % t == 0;\n}\n\nfunction assertValidResolution(e, t) {\n  tf.util.assert(\"number\" == typeof e[0] && \"number\" == typeof e[1], function () {\n    return \"both resolution values must be a number but had values \" + e;\n  }), tf.util.assert(isValidInputResolution(e[0], t), function () {\n    return \"height of \" + e[0] + \" is invalid for output stride \" + t + \".\";\n  }), tf.util.assert(isValidInputResolution(e[1], t), function () {\n    return \"width of \" + e[1] + \" is invalid for output stride \" + t + \".\";\n  });\n}\n\nfunction getInputTensorDimensions(e) {\n  return e instanceof tf.Tensor ? [e.shape[0], e.shape[1]] : [e.height, e.width];\n}\n\nfunction toInputTensor(e) {\n  return e instanceof tf.Tensor ? e : tf.browser.fromPixels(e);\n}\n\nfunction padAndResizeTo(e, t) {\n  var n = t[0],\n      r = t[1],\n      o = getInputTensorDimensions(e),\n      i = o[0],\n      s = o[1],\n      u = r / n,\n      a = [0, 0, 0, 0],\n      l = a[0],\n      p = a[1],\n      c = a[2],\n      f = a[3];\n  return s / i < u ? (l = 0, p = 0, c = Math.round(.5 * (u * i - s)), f = Math.round(.5 * (u * i - s))) : (l = Math.round(.5 * (1 / u * s - i)), p = Math.round(.5 * (1 / u * s - i)), c = 0, f = 0), {\n    resized: (0, tf.tidy)(function () {\n      var t = toInputTensor(e);\n      return (t = (0, tf.pad3d)(t, [[l, p], [c, f], [0, 0]])).resizeBilinear([n, r]);\n    }),\n    padding: {\n      top: l,\n      left: c,\n      right: f,\n      bottom: p\n    }\n  };\n}\n\nfunction scaleAndFlipPoses(e, t, n, r, o) {\n  var i = t[0],\n      s = t[1],\n      u = n[0],\n      a = n[1],\n      l = scalePoses(e, (i + r.top + r.bottom) / u, (s + r.left + r.right) / a, -r.top, -r.left);\n  return o ? flipPosesHorizontal(l, s) : l;\n}\n\nvar MOBILENET_V1_CONFIG = {\n  architecture: \"MobileNetV1\",\n  outputStride: 16,\n  multiplier: .75,\n  inputResolution: 257\n},\n    VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n    VALID_STRIDE = {\n  MobileNetV1: [8, 16, 32],\n  ResNet50: [32, 16]\n},\n    VALID_MULTIPLIER = {\n  MobileNetV1: [.5, .75, 1],\n  ResNet50: [1]\n},\n    VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.inputResolution && (e.inputResolution = 257), validateInputResolution(e.inputResolution), null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecutre \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecutre \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecutre \" + e.architecture + \".\");\n  return e;\n}\n\nvar SINGLE_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1\n},\n    MULTI_PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  maxDetections: 5,\n  scoreThreshold: .5,\n  nmsRadius: 20\n};\n\nfunction validateMultiPersonInputConfig(e) {\n  var t = e.maxDetections,\n      n = e.scoreThreshold,\n      r = e.nmsRadius;\n  if (t <= 0) throw new Error(\"Invalid maxDetections \" + t + \". Should be > 0\");\n  if (n < 0 || n > 1) throw new Error(\"Invalid scoreThreshold \" + n + \". Should be in range [0.0, 1.0]\");\n  if (r <= 0) throw new Error(\"Invalid nmsRadius \" + r + \".\");\n}\n\nvar PoseNet = function () {\n  function e(e, t) {\n    assertValidOutputStride(e.outputStride), assertValidResolution(t, e.outputStride), this.baseModel = e, this.inputResolution = t;\n  }\n\n  return e.prototype.estimateMultiplePoses = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _, I, v, y, E, b;\n\n      return __generator(this, function (N) {\n        switch (N.label) {\n          case 0:\n            return n = __assign({}, MULTI_PERSON_INFERENCE_CONFIG, t), validateMultiPersonInputConfig(t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, toTensorBuffers3D([f, d, h, m])];\n\n          case 1:\n            return g = N.sent(), _ = g[0], I = g[1], v = g[2], y = g[3], [4, decodeMultiplePoses(_, I, v, y, r, n.maxDetections, n.scoreThreshold, n.nmsRadius)];\n\n          case 2:\n            return E = N.sent(), b = scaleAndFlipPoses(E, [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, b];\n        }\n      });\n    });\n  }, e.prototype.estimateSinglePose = function (e, t) {\n    return void 0 === t && (t = SINGLE_PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, s, u, a, l, p, c, f, d, h, m, g, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return n = __assign({}, SINGLE_PERSON_INFERENCE_CONFIG, t), r = this.baseModel.outputStride, o = this.inputResolution, i = getInputTensorDimensions(e), s = i[0], u = i[1], a = padAndResizeTo(e, o), l = a.resized, p = a.padding, c = this.baseModel.predict(l), f = c.heatmapScores, d = c.offsets, h = c.displacementFwd, m = c.displacementBwd, [4, decodeSinglePose(f, d, r)];\n\n          case 1:\n            return g = I.sent(), _ = scaleAndFlipPoses([g], [s, u], o, p, n.flipHorizontal), f.dispose(), d.dispose(), h.dispose(), m.dispose(), l.dispose(), [2, _[0]];\n        }\n      });\n    });\n  }, e.prototype.estimatePoses = function (e, t) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (n) {\n        switch (n.label) {\n          case 0:\n            return \"single-person\" !== t.decodingMethod ? [3, 2] : [4, this.estimateSinglePose(e, t)];\n\n          case 1:\n            return [2, [n.sent()]];\n\n          case 2:\n            return [2, this.estimateMultiplePoses(e, t)];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\n\nexports.PoseNet = PoseNet;\n\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s, u;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetCheckpoint(t, r, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || o)];\n\n        case 1:\n          return i = a.sent(), s = new MobileNet(i, t), u = getValidInputResolutionDimensions(e.inputResolution, s.outputStride), [2, new PoseNet(s, u)];\n      }\n    });\n  });\n}\n\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, s;\n    return __generator(this, function (u) {\n      switch (u.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return r = resNet50Checkpoint(t, n), [4, (0, _tfjsConverter.loadGraphModel)(e.modelUrl || r)];\n\n        case 1:\n          return o = u.sent(), i = new ResNet(o, t), s = getValidInputResolutionDimensions(e.inputResolution, i.outputStride), [2, new PoseNet(i, s)];\n      }\n    });\n  });\n}\n\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\n\nvar version = \"2.2.1\";\nexports.version = version;"},"sourceMaps":null,"error":null,"hash":"804a7ea0868bc1c6a6beec0842e5b0dd","cacheData":{"env":{}}}