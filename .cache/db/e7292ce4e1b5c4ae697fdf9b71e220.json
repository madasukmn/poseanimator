{"id":"illustrationGen/illustration.js","dependencies":[{"name":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/package.json","includedInParent":true,"mtime":1636789466000},{"name":"./skeleton","loc":{"line":18,"column":45},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/illustrationGen/illustration.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/illustrationGen/skeleton.js"},{"name":"../utils/mathUtils","loc":{"line":19,"column":26},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/illustrationGen/illustration.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/utils/mathUtils.js"},{"name":"../utils/svgUtils","loc":{"line":20,"column":25},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/illustrationGen/illustration.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/utils/svgUtils.js"},{"name":"../utils/colorUtils","loc":{"line":21,"column":27},"parent":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/illustrationGen/illustration.js","resolved":"/Users/kmadasu/kishore/trainings/javascript-gt/gautam/poseanimator/utils/colorUtils.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PoseIllustration = void 0;\n\nvar _skeleton = require(\"./skeleton\");\n\nvar _mathUtils = require(\"../utils/mathUtils\");\n\nvar _svgUtils = require(\"../utils/svgUtils\");\n\nvar _colorUtils = require(\"../utils/colorUtils\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar allPartNamesMap = {};\n\n_skeleton.allPartNames.forEach(function (name) {\n  return allPartNamesMap[name] = 1;\n});\n\nvar MIN_CONFIDENCE_PATH_SCORE = 0.3; // Represents a skinned illustration.\n\nvar PoseIllustration = /*#__PURE__*/function () {\n  function PoseIllustration(scope) {\n    _classCallCheck(this, PoseIllustration);\n\n    this.scope = scope;\n    this.frames = [];\n  }\n\n  _createClass(PoseIllustration, [{\n    key: \"updateSkeleton\",\n    value: function updateSkeleton(pose, face) {\n      this.pose = pose;\n      this.face = face;\n      this.skeleton.update(pose, face);\n\n      if (!this.skeleton.isValid) {\n        return;\n      }\n\n      var getConfidenceScore = function getConfidenceScore(p) {\n        return Object.keys(p.skinning).reduce(function (totalScore, boneName) {\n          var bt = p.skinning[boneName];\n          return totalScore + bt.bone.score * bt.weight;\n        }, 0);\n      };\n\n      this.skinnedPaths.forEach(function (skinnedPath) {\n        var confidenceScore = 0;\n        skinnedPath.segments.forEach(function (seg) {\n          // Compute confidence score.\n          confidenceScore += getConfidenceScore(seg.point); // Compute new positions for curve point and handles.\n\n          seg.point.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.point);\n\n          if (seg.handleIn) {\n            seg.handleIn.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.handleIn);\n          }\n\n          if (seg.handleOut) {\n            seg.handleOut.currentPosition = _skeleton.Skeleton.getCurrentPosition(seg.handleOut);\n          }\n        });\n        skinnedPath.confidenceScore = confidenceScore / (skinnedPath.segments.length || 1);\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      if (!this.skeleton.isValid) {\n        return;\n      }\n\n      var scope = this.scope; // Add paths\n\n      this.skinnedPaths.forEach(function (skinnedPath) {\n        // Do not render paths with low confidence scores.\n        if (!skinnedPath.confidenceScore || skinnedPath.confidenceScore < MIN_CONFIDENCE_PATH_SCORE) {\n          return;\n        }\n\n        var path = new scope.Path({\n          fillColor: skinnedPath.fillColor,\n          strokeColor: skinnedPath.strokeColor,\n          strokeWidth: skinnedPath.strokeWidth,\n          closed: skinnedPath.closed\n        });\n        skinnedPath.segments.forEach(function (seg) {\n          path.addSegment(seg.point.currentPosition, seg.handleIn ? seg.handleIn.currentPosition.subtract(seg.point.currentPosition) : null, seg.handleOut ? seg.handleOut.currentPosition.subtract(seg.point.currentPosition) : null);\n        });\n\n        if (skinnedPath.closed) {\n          path.closePath();\n        }\n\n        scope.project.activeLayer.addChild(path);\n      });\n    }\n  }, {\n    key: \"debugDraw\",\n    value: function debugDraw() {\n      var scope = this.scope;\n      var group = new scope.Group();\n      scope.project.activeLayer.addChild(group);\n\n      var drawCircle = function drawCircle(p) {\n        var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        group.addChild(new scope.Path.Circle({\n          center: [p.x, p.y],\n          radius: opt.radius || 2,\n          fillColor: opt.fillColor || 'red'\n        }));\n      };\n\n      var drawLine = function drawLine(p0, p1) {\n        var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        group.addChild(new scope.Path({\n          segments: [p0, p1],\n          strokeColor: opt.strokeColor || 'red',\n          strokeWidth: opt.strokeWidth || 1\n        }));\n      }; // Draw skeleton.\n\n\n      this.skeleton.debugDraw(scope); // Draw curve and handles.\n\n      this.skinnedPaths.forEach(function (skinnedPath) {\n        skinnedPath.segments.forEach(function (seg) {\n          // Color represents weight influence from bones.\n          var color = new scope.Color(0);\n          Object.keys(seg.point.skinning).forEach(function (boneName) {\n            var bt = seg.point.skinning[boneName];\n\n            _colorUtils.ColorUtils.addRGB(color, bt.weight * bt.bone.boneColor.red, bt.weight * bt.bone.boneColor.green, bt.weight * bt.bone.boneColor.blue);\n\n            var anchor = bt.bone.kp0.currentPosition.multiply(1 - bt.transform.anchorPerc).add(bt.bone.kp1.currentPosition.multiply(bt.transform.anchorPerc));\n            drawLine(anchor, seg.point.currentPosition, {\n              strokeColor: 'blue',\n              strokeWidth: bt.weight\n            });\n          });\n          drawCircle(seg.point.currentPosition, {\n            fillColor: color\n          });\n          drawCircle(seg.handleIn.currentPosition, {\n            fillColor: color\n          });\n          drawLine(seg.point.currentPosition, seg.handleIn.currentPosition, {\n            strokeColor: color\n          });\n          drawCircle(seg.handleOut.currentPosition, {\n            fillColor: color\n          }, {\n            strokeColor: color\n          });\n          drawLine(seg.point.currentPosition, seg.handleOut.currentPosition);\n        });\n      });\n    }\n  }, {\n    key: \"debugDrawLabel\",\n    value: function debugDrawLabel(scope) {\n      this.skeleton.debugDrawLabels(scope);\n    }\n  }, {\n    key: \"bindSkeleton\",\n    value: function bindSkeleton(skeleton, skeletonScope) {\n      var items = skeletonScope.project.getItems({\n        recursive: true\n      });\n      items = items.filter(function (item) {\n        return item.parent && item.parent.name && item.parent.name.startsWith('illustration');\n      });\n      this.skeleton = skeleton;\n      this.skinnedPaths = []; // Only support rendering path and shapes for now.\n\n      for (var i = 0; i < items.length; i++) {\n        var item = items[i];\n\n        if (_svgUtils.SVGUtils.isGroup(item)) {\n          this.bindGroup(item, skeleton);\n        } else if (_svgUtils.SVGUtils.isPath(item)) {\n          this.bindPathToBones(item);\n        } else if (_svgUtils.SVGUtils.isShape(item)) {\n          this.bindPathToBones(item.toPath());\n        }\n      }\n    }\n  }, {\n    key: \"bindGroup\",\n    value: function bindGroup(group, skeleton) {\n      var _this = this;\n\n      var paths = [];\n      var keypoints = {};\n      var items = group.getItems({\n        recursive: true\n      }); // Find all paths and included keypoints.\n\n      items.forEach(function (item) {\n        var partName = item.name ? _skeleton.allPartNames.find(function (partName) {\n          return item.name.startsWith(partName);\n        }) : null;\n\n        if (partName) {\n          keypoints[partName] = {\n            position: item.bounds.center,\n            name: partName\n          };\n        } else if (_svgUtils.SVGUtils.isPath(item)) {\n          paths.push(item);\n        } else if (_svgUtils.SVGUtils.isShape(item)) {\n          paths.push(item.toPath());\n        }\n      });\n      var secondaryBones = []; // Find all parent bones of the included keypoints.\n\n      var parentBones = skeleton.bones.filter(function (bone) {\n        return keypoints[bone.kp0.name] && keypoints[bone.kp1.name];\n      });\n      var nosePos = skeleton.bNose3Nose4.kp1.position;\n\n      if (!parentBones.length) {\n        return;\n      } // Crete secondary bones for the included keypoints.\n\n\n      parentBones.forEach(function (parentBone) {\n        var kp0 = keypoints[parentBone.kp0.name];\n        var kp1 = keypoints[parentBone.kp1.name];\n        var secondaryBone = new _skeleton.Bone().set(kp0, kp1, parentBone.skeleton, parentBone.type);\n        kp0.transformFunc = _mathUtils.MathUtils.getTransformFunc(parentBone.kp0.position, nosePos, kp0.position);\n        kp1.transformFunc = _mathUtils.MathUtils.getTransformFunc(parentBone.kp1.position, nosePos, kp1.position);\n        secondaryBone.parent = parentBone;\n        secondaryBones.push(secondaryBone);\n      });\n      skeleton.secondaryBones = skeleton.secondaryBones.concat(secondaryBones);\n      paths.forEach(function (path) {\n        _this.bindPathToBones(path, secondaryBones);\n      });\n    } // Assign weights from bones for point.\n    // Weight calculation is roughly based on linear blend skinning model.\n\n  }, {\n    key: \"getWeights\",\n    value: function getWeights(point, bones) {\n      var totalW = 0;\n      var weights = {};\n      bones.forEach(function (bone) {\n        var d = _mathUtils.MathUtils.getClosestPointOnSegment(bone.kp0.position, bone.kp1.position, point).getDistance(point); // Absolute weight = 1 / (distance * distance)\n\n\n        var w = 1 / (d * d);\n        weights[bone.name] = {\n          value: w,\n          bone: bone\n        };\n      });\n      var values = Object.values(weights).sort(function (v0, v1) {\n        return v1.value - v0.value;\n      });\n      weights = {};\n      totalW = 0;\n      values.forEach(function (v) {\n        weights[v.bone.name] = v;\n        totalW += v.value;\n      });\n\n      if (totalW === 0) {\n        // Point is outside of the influence zone of all bones. It will not be influence by any bone.\n        return {};\n      } // Normalize weights to sum up to 1.\n\n\n      Object.values(weights).forEach(function (weight) {\n        weight.value /= totalW;\n      });\n      return weights;\n    } // Binds a path to bones by compute weight contribution from each bones for each path segment.\n    // If selectedBones are set, bind directly to the selected bones. Otherwise auto select the bone group closest to each segment.\n\n  }, {\n    key: \"bindPathToBones\",\n    value: function bindPathToBones(path, selectedBones) {\n      var _this2 = this;\n\n      // Compute bone weights for each segment.\n      var segs = path.segments.map(function (s) {\n        // Check if control points are collinear.\n        // If so, use the middle point's weight for all three points (curve point, handleIn, handleOut).\n        // This makes sure smooth curves remain smooth after deformation.\n        var collinear = _mathUtils.MathUtils.isCollinear(s.handleIn, s.handleOut);\n\n        var bones = selectedBones || _this2.skeleton.findBoneGroup(s.point);\n\n        var weightsP = _this2.getWeights(s.point, bones);\n\n        var segment = {\n          point: _this2.getSkinning(s.point, weightsP)\n        }; // For handles, compute transformation in world space.\n\n        if (s.handleIn) {\n          var pHandleIn = s.handleIn.add(s.point);\n          segment.handleIn = _this2.getSkinning(pHandleIn, collinear ? weightsP : _this2.getWeights(pHandleIn, bones));\n        }\n\n        if (s.handleOut) {\n          var pHandleOut = s.handleOut.add(s.point);\n          segment.handleOut = _this2.getSkinning(pHandleOut, collinear ? weightsP : _this2.getWeights(pHandleOut, bones));\n        }\n\n        return segment;\n      });\n      this.skinnedPaths.push({\n        segments: segs,\n        fillColor: path.fillColor,\n        strokeColor: path.strokeColor,\n        strokeWidth: path.strokeWidth,\n        closed: path.closed\n      });\n    }\n  }, {\n    key: \"getSkinning\",\n    value: function getSkinning(point, weights) {\n      var skinning = {};\n      Object.keys(weights).forEach(function (boneName) {\n        skinning[boneName] = {\n          bone: weights[boneName].bone,\n          weight: weights[boneName].value,\n          transform: weights[boneName].bone.getPointTransform(point)\n        };\n      });\n      return {\n        skinning: skinning,\n        position: point,\n        currentPosition: new this.scope.Point(0, 0)\n      };\n    }\n  }]);\n\n  return PoseIllustration;\n}();\n\nexports.PoseIllustration = PoseIllustration;"},"sourceMaps":null,"error":null,"hash":"8c62ddf1e9aec07b87225906233e62e1","cacheData":{"env":{}}}